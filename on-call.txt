 Plan: On-Call Management with Service Grouping                                                                                                                                                                
                                                                                                                                                                                                               
 Context                                                                                                                                                                                                       
                                                                                                                                                                                                               
 Currently ServiceTeamMapping is a flat table — each service has a primary_oncall Slack user ID stored directly on it. There is no concept of grouping services together or of a group-level on-call rotation.
  When the agent escalates, escalate_to_humans posts a generic message without mentioning any Slack user, so no one actually gets paged.

 This plan introduces:
 1. A ServiceGroup entity — multiple services belong to one group, and the group has a single on-call engineer at any time.
 2. A service_owner field per service — distinct from the rotating on-call; this is the service's permanent tech owner.
 3. Improved lookup_service_owner tool — returns group name + group on-call so the agent knows who to tag.
 4. Actual Slack tagging on escalation — the workflow looks up on-call Slack IDs before calling escalate_to_humans.

 ---
 Files to Modify

 ┌──────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────┐
 │                         File                         │                                    Change                                     │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/models/models.py                         │ Add ServiceGroup model; add service_owner + group_id FK to ServiceTeamMapping │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/schemas/admin.py                         │ Add ServiceGroup* schemas; update ServiceTeamMapping* schemas                 │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/db/repository.py                         │ Add ServiceGroup CRUD + get_oncall_for_services helper                        │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/api/admin.py                             │ Add /service-groups CRUD endpoints; update service mapping endpoints          │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/agent/tools.py                           │ Improve _lookup_service_owner_sync — JOIN with service_groups                 │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/temporal/activities/database_activity.py │ Add fetch_oncall_for_services activity                                        │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/temporal/activities/slack_activity.py    │ Add oncall_mentions to EscalationInput; tag them in the message               │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ src/bug_bot/temporal/workflows/bug_investigation.py  │ Call fetch_oncall_for_services before escalate_to_humans                      │
 ├──────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────┤
 │ alembic/versions/<new>.py                            │ Migration: create service_groups, add columns to service_team_mapping         │
 └──────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────┘

 ---
 Step-by-Step Implementation

 Step 1 — ORM Models (models.py)

 Add new ServiceGroup model before ServiceTeamMapping:

 class ServiceGroup(Base):
     __tablename__ = "service_groups"

     id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
     group_name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)
     oncall_engineer: Mapped[str | None] = mapped_column(String(20))   # Slack user ID
     group_slack_handle: Mapped[str | None] = mapped_column(String(30))  # Slack subteam ID
     created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
     updated_at: Mapped[datetime] = mapped_column(
         DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
     )
     services: Mapped[list["ServiceTeamMapping"]] = relationship(back_populates="group")

 Update ServiceTeamMapping:
 - Add service_owner: Mapped[str | None] = mapped_column(String(20)) — permanent tech owner Slack ID
 - Add group_id: Mapped[uuid.UUID | None] = mapped_column(UUID(as_uuid=True), ForeignKey("service_groups.id", ondelete="SET NULL"), nullable=True)
 - Add group: Mapped["ServiceGroup | None"] = relationship(back_populates="services")

 Keep existing primary_oncall as a service-level fallback (no rename to avoid data migration complexity).

 ---
 Step 2 — Alembic Migration

 New file alembic/versions/<hash>_add_service_groups.py:

 -- upgrade
 CREATE TABLE service_groups (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     group_name VARCHAR(100) NOT NULL UNIQUE,
     oncall_engineer VARCHAR(20),
     group_slack_handle VARCHAR(30),
     created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
     updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
 );

 ALTER TABLE service_team_mapping
     ADD COLUMN service_owner VARCHAR(20),
     ADD COLUMN group_id UUID REFERENCES service_groups(id) ON DELETE SET NULL;

 CREATE INDEX idx_service_team_mapping_group_id ON service_team_mapping(group_id);

 -- downgrade
 ALTER TABLE service_team_mapping DROP COLUMN group_id, DROP COLUMN service_owner;
 DROP TABLE service_groups;

 ---
 Step 3 — Pydantic Schemas (schemas/admin.py)

 Add ServiceGroup schemas:
 class ServiceGroupBase(BaseModel):
     group_name: str
     oncall_engineer: str | None = None
     group_slack_handle: str | None = None

 class ServiceGroupCreate(ServiceGroupBase): pass

 class ServiceGroupUpdate(BaseModel):
     group_name: str | None = None
     oncall_engineer: str | None = None
     group_slack_handle: str | None = None

 class ServiceGroupResponse(ServiceGroupBase):
     id: str
     created_at: datetime
     updated_at: datetime

 class PaginatedServiceGroups(BaseModel):
     items: list[ServiceGroupResponse]
     total: NonNegativeInt
     page: int
     page_size: int

 Update ServiceTeamMappingBase to add:
 service_owner: str | None = None
 group_id: str | None = None

 Update ServiceTeamMappingResponse to include embedded group summary:
 class ServiceGroupSummary(BaseModel):
     id: str
     group_name: str
     oncall_engineer: str | None

 class ServiceTeamMappingResponse(ServiceTeamMappingBase):
     id: str
     created_at: datetime
     group: ServiceGroupSummary | None = None  # populated when group_id is set

 ---
 Step 4 — Repository (db/repository.py)

 Add ServiceGroup CRUD (mirroring existing ServiceTeamMapping pattern):
 - create_service_group(data: dict) -> ServiceGroup
 - get_service_group_by_id(id_: str) -> ServiceGroup | None
 - list_service_groups(page, page_size) -> tuple[list[ServiceGroup], int]
 - update_service_group(id_: str, data: dict) -> ServiceGroup | None
 - delete_service_group(id_: str) -> None

 Add on-call lookup helper:
 async def get_oncall_for_services(self, service_names: list[str]) -> list[str]:
     """Return deduped Slack user IDs of on-call engineers for the given services.
     Prefers group oncall_engineer; falls back to service primary_oncall."""
     stmt = (
         select(ServiceTeamMapping, ServiceGroup)
         .outerjoin(ServiceGroup, ServiceTeamMapping.group_id == ServiceGroup.id)
         .where(func.lower(ServiceTeamMapping.service_name).in_(
             [s.lower() for s in service_names]
         ))
     )
     results = await self.session.execute(stmt)
     mentions: list[str] = []
     for mapping, group in results.all():
         oncall = (group.oncall_engineer if group else None) or mapping.primary_oncall
         if oncall and oncall not in mentions:
             mentions.append(oncall)
     return mentions

 Also add eager_load_group option to get_service_mapping for the admin GET endpoint.

 ---
 Step 5 — Admin API (api/admin.py)

 Add 5 new /service-groups endpoints (same CRUD pattern as existing /service-team-mappings):
 - GET /service-groups — paginated list
 - POST /service-groups — create
 - GET /service-groups/{id} — get single
 - PATCH /service-groups/{id} — update
 - DELETE /service-groups/{id} — delete (hard delete)

 Update service mapping response construction to eager-load .group and populate the embedded ServiceGroupSummary.

 ---
 Step 6 — Improved lookup_service_owner Tool (agent/tools.py)

 Update _lookup_service_owner_sync SQL:

 SELECT
     s.service_name, s.github_repo, s.tech_stack,
     s.team_slack_group, s.service_owner, s.primary_oncall,
     g.group_name, g.oncall_engineer AS group_oncall
 FROM service_team_mapping s
 LEFT JOIN service_groups g ON s.group_id = g.id
 WHERE lower(s.service_name) = lower(%s)
 LIMIT 1;

 New response format:
 Service: {service_name}
 GitHub repo: {github_repo}
 Tech stack: {tech_stack}
 Service owner: {service_owner or primary_oncall or 'N/A'}
 Group: {group_name or 'Ungrouped'}
 Group on-call: {group_oncall or 'N/A'}
 Team Slack group: {team_slack_group or 'N/A'}

 The agent can now read Group on-call directly and reference it when reporting or escalating.

 ---
 Step 7 — fetch_oncall_for_services Activity (activities/database_activity.py)

 @activity.defn
 async def fetch_oncall_for_services(service_names: list[str]) -> list[str]:
     """Return Slack user IDs of on-call engineers for the given service names."""
     async with async_session() as session:
         repo = BugRepository(session)
         return await repo.get_oncall_for_services(service_names)

 ---
 Step 8 — Escalation Slack Message (activities/slack_activity.py)

 Update EscalationInput:
 @dataclass
 class EscalationInput:
     channel_id: str
     thread_ts: str
     bug_id: str
     severity: str
     relevant_services: list[str]
     escalation_level: int = 1
     oncall_mentions: list[str] = field(default_factory=list)  # new

 Update escalate_to_humans to build mention string:
 mention_str = " ".join(f"<@{uid}>" for uid in input.oncall_mentions)
 msg = (
     f"Escalation (Level {input.escalation_level}) for {input.bug_id} "
     f"(Severity: {input.severity}) — "
     f"Services: {', '.join(input.relevant_services) or 'Unknown'} — "
     f"Requires human investigation."
 )
 text = f":rotating_light: *{msg}*"
 if mention_str:
     text += f"\n{mention_str} please investigate."

 ---
 Step 9 — Workflow Update (workflows/bug_investigation.py)

 Import the new activity and call it before escalate_to_humans:

 from bug_bot.temporal.activities.database_activity import (
     ...,
     fetch_oncall_for_services,
 )

 # In the escalate branch:
 if action == "escalate":
     oncall_mentions: list[str] = await workflow.execute_activity(
         fetch_oncall_for_services,
         args=[investigation_dict.get("relevant_services", [])],
         start_to_close_timeout=timedelta(seconds=10),
     )
     await workflow.execute_activity(
         escalate_to_humans,
         EscalationInput(
             channel_id=input.channel_id, thread_ts=input.thread_ts,
             bug_id=input.bug_id, severity=parsed.severity,
             relevant_services=investigation_dict.get("relevant_services", []),
             oncall_mentions=oncall_mentions,
         ),
         start_to_close_timeout=timedelta(seconds=15),
     )

 ---
 Data Flow After Changes

 ServiceGroup: "Payments" (oncall: U_ALICE)
   └── ServiceTeamMapping: "Payment" (service_owner: U_BOB, group_id → Payments)
   └── ServiceTeamMapping: "Bill"    (service_owner: U_CAROL, group_id → Payments)

 ServiceGroup: "Auth & Identity" (oncall: U_DAVE)
   └── ServiceTeamMapping: "Auth"    (service_owner: U_EVE, group_id → Auth & Identity)
   └── ServiceTeamMapping: "Company" (service_owner: U_FRANK, group_id → Auth & Identity)

 Bug filed for "Payment" → agent calls lookup_service_owner("Payment")
   → Returns: Group: Payments, Group on-call: U_ALICE, Service owner: U_BOB
   → action == "escalate"
   → fetch_oncall_for_services(["Payment"]) → ["U_ALICE"]
   → Slack: "@alice please investigate."

 ---
 Verification

 1. Run migration: alembic upgrade head — confirm service_groups table created, new columns appear in service_team_mapping.
 2. Create a group via API: POST /service-groups with group_name, oncall_engineer.
 3. Assign a service: PATCH /service-team-mappings/{id} with group_id and service_owner.
 4. Call GET /service-team-mappings/{id} — confirm group nested object is returned.
 5. Trigger a test investigation (or unit-test _lookup_service_owner_sync) — confirm new fields appear in tool output.
 6. Trigger escalation path — confirm the Slack message includes <@oncall_user_id>.